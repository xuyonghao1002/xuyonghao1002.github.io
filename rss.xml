<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>夜行</title>
        <link>https://xuyonghao1002.github.io/</link>
        <description>游戏服务端开发 Blog</description>
        <lastBuildDate>Sat, 31 Dec 2022 08:59:03 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh</language>
        <copyright>Copyright © 2022 夜行 Built with Docusaurus.&lt;p&gt;&lt;a href="http://beian.miit.gov.cn/" class="footer_lin"&gt;闽ICP备2020017848号-2&lt;/a&gt;&lt;/p&gt;</copyright>
        <item>
            <title><![CDATA[program/服务端面试]]></title>
            <link>https://xuyonghao1002.github.io/program/服务端面试</link>
            <guid>/program/服务端面试</guid>
            <pubDate>Sat, 31 Dec 2022 08:59:03 GMT</pubDate>
            <description><![CDATA[项目]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="项目">项目<a class="hash-link" href="#项目" title="标题的直接链接">​</a></h2><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="游戏框架熟悉程度">游戏框架熟悉程度<a class="hash-link" href="#游戏框架熟悉程度" title="标题的直接链接">​</a></h4><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="对游戏框架做过哪些改进具体从哪些方面出发进行改进">对游戏框架做过哪些改进，具体从哪些方面出发进行改进<a class="hash-link" href="#对游戏框架做过哪些改进具体从哪些方面出发进行改进" title="标题的直接链接">​</a></h4><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="排行榜模块的实现">排行榜模块的实现<a class="hash-link" href="#排行榜模块的实现" title="标题的直接链接">​</a></h4><ul><li>用了什么数据结构<ul><li>小根堆排行榜</li><li>堆排序<ul><li>建堆，调整堆</li><li>建堆的时间复杂度是O(n)</li><li>堆的插入、删除元素的时间复杂度都是O(log n)</li><li>堆排序的时间复杂度是O(n logn)</li></ul></li></ul></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="事件模块时间模块">事件模块、时间模块<a class="hash-link" href="#事件模块时间模块" title="标题的直接链接">​</a></h4><ul><li>时间轮</li><li>时间堆<ul><li>用大根堆还是小根堆</li></ul></li><li>优先级队列</li><li>用堆来实现一个优先级队列<ul><li>排序稳定性：你该如何令相同优先级的两个任务按它们最初被加入时的顺序返回？</li><li>如果优先级相同且任务没有默认比较顺序，则 (priority, task) 对的元组比较将会中断。</li><li>如果任务优先级发生改变，你该如何将其移至堆中的新位置？</li><li>或者如果一个挂起的任务需要被删除，你该如何找到它并将其移出队列？</li><li>针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。</li></ul></li><li>topK问题， 有一组无序的数据，且数量庞大，求前K个最小的元素或者前K个最大的元素<ul><li>建立大小为 N 的小堆，每次弹出堆顶元素，弹 K 次 （不常用）
建立大小为 K 的大堆（求前K个最大的元素建小堆）
1 ) 将待排序序列的前 K 个元素，建成大根堆
2 ) 遍历剩下的待排序序列，每拿到一个数字，就和当前堆顶元素比较
3 ) 如果比当前的堆顶元素大，不care
4 ) 如果比堆顶元素小，那么弹出堆顶元素，将待排序序列当中的数字放到堆中
第4）中的弹出和放入都对应了一次调整为大根堆的过程</li></ul></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="聊天系统">聊天系统<a class="hash-link" href="#聊天系统" title="标题的直接链接">​</a></h4><ul><li>容灾处理：当某个game进程挂掉之后，会触发容灾，让中心节点移除当前game进程的所有聊天频道，并剔除要移除频道内的所有玩家</li><li>向离线玩家发送rpc，怎么处理，数据库存储多少rpc<ul><li>将rpc存储到数据库，目标eid、方法名、当前时间、有效期、方法参数</li><li>有效期默认为7天，7天之后会自动删除，这里利用了mongodb的TTL索引机制，<em>expireAfterSeconds</em> = 3600 <em> 24 </em> 7</li><li>离线玩家上线时，会去数据库load和自己相关的offline_opetator，然后执行相应方法，删除数据库相应数据</li><li>目前没做存储上限，可用定长</li><li>以目标玩家eid、时间、方法名 建立索引，当目标玩家上线时，去数据库load数据</li></ul></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="全服广播">全服广播<a class="hash-link" href="#全服广播" title="标题的直接链接">​</a></h4><p>中心节点广播到各game进程，game进程在进程内部调用avatar方法，然后avatar发送rpc到client</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="登录流程">登录流程<a class="hash-link" href="#登录流程" title="标题的直接链接">​</a></h4><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="顶号如何实现">顶号如何实现<a class="hash-link" href="#顶号如何实现" title="标题的直接链接">​</a></h4><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="面向服务编程">面向服务编程<a class="hash-link" href="#面向服务编程" title="标题的直接链接">​</a></h2><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="soa的概念">SOA的概念<a class="hash-link" href="#soa的概念" title="标题的直接链接">​</a></h4><p>SOA是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非采用进程内调用的方式进行通信。</p><p>按照业务功能将本来一整块的系统拆分为各个不同的子系统分别提供不同的服务，服务之间通过接口相互调用。这就是所谓的“面向服务的架构”。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="soa的好处">SOA的好处<a class="hash-link" href="#soa的好处" title="标题的直接链接">​</a></h4><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="soa和微服务的区别">SOA和微服务的区别<a class="hash-link" href="#soa和微服务的区别" title="标题的直接链接">​</a></h4><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="c-面向对象编程">C++ 面向对象编程<a class="hash-link" href="#c-面向对象编程" title="标题的直接链接">​</a></h2><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="python">Python<a class="hash-link" href="#python" title="标题的直接链接">​</a></h2><ul><li>gc机制<ul><li>引用计数</li><li>标记清除</li><li>分代回收</li></ul></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="操作系统">操作系统<a class="hash-link" href="#操作系统" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="进程线程协程">进程、线程、协程<a class="hash-link" href="#进程线程协程" title="标题的直接链接">​</a></h3><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="网络">网络<a class="hash-link" href="#网络" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="tcp">TCP<a class="hash-link" href="#tcp" title="标题的直接链接">​</a></h3><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="udp">UDP<a class="hash-link" href="#udp" title="标题的直接链接">​</a></h3><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="io复用">IO复用<a class="hash-link" href="#io复用" title="标题的直接链接">​</a></h3><ul><li>比如epoll和select的区别是什么？</li><li>epoll高效率的原因是什么？</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="select">select<a class="hash-link" href="#select" title="标题的直接链接">​</a></h4><ul><li>缺点<ul><li>其一，每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket。</li><li>其二，进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次。</li></ul></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="epoll">epoll<a class="hash-link" href="#epoll" title="标题的直接链接">​</a></h4><ul><li><p><strong>措施一：功能分离</strong></p><p>select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见的，效率就能得到提升。</p><p>先用epoll_create创建一个epoll对象epfd，再通过epoll_ctl将需要监视的socket添加到epfd中，最后调用epoll_wait等待数据。</p></li><li><p><strong>措施二：就绪列表</strong></p><p>select低效的另一个原因在于程序不知道哪些socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。如下图所示，计算机共有三个socket，收到数据的sock2和sock3被rdlist（就绪列表）所引用。当进程被唤醒后，只要获取rdlist的内容，就能够知道哪些socket收到数据。</p></li><li><p>首先是epoll_create创建一个event_poll对象，并将其添加到文件系统中，和普通socket一样，也有等待队列（存储的是等待的进程），然后使用epoll_ctl将需要监听的文件描述符添加到一个红黑树数据结构中，并注册相应的回调函数<!-- -->[即将时间到来时候会将socket放在rdlist链表中]<!-- -->，最后使用epoll_wait函数，它会将调用的进程移除到内核的工作队列，然后将该进程添加到等待队列中，然后如果这时候有socket的事件到来，中断处理函数会调用回调函数将socket添加到eventpoll对象所维护的一个就绪列表中<!-- -->[双向链表，方便插入删除]<!-- -->，然后eventpoll会将等待队列中的进程唤醒，并加入到内核的工作队列中</p></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据库">数据库<a class="hash-link" href="#数据库" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="mongo">mongo<a class="hash-link" href="#mongo" title="标题的直接链接">​</a></h3><ul><li><p>mongo数据库分布式事务</p></li><li><p>MongoDB的分布式事务是基于<strong>两阶段协议</strong>。 第一阶段就是prepare阶段，在prepare过程中，所有的coordinator会向所有的节点去发送prepare命令，所有的节点收到了这个命令以后会返回自己的prepare timestamp，然后由协调节点去决定选取一个最大的prepare ts作为commit timestamp。 coordinator和所有的shard之间的通讯会促使所有的事务参与者得到一个协调一致的HLC。 在这种逻辑时钟一致的情况下，commit timestamp就是全局顺序一致的。 第二阶段的话就是提交阶段， coordinator会将刚刚的committed ts作为commit timestamp的时间戳，然后向所有的节点去广播。</p></li><li><p>mongo单个文档限制大小是多少</p><ul><li>16M</li></ul></li><li><p>objectid是什么</p><ul><li><p>ObjectId 是一个12字节 BSON 类型数据，有以下格式：</p><ul><li>前4个字节表示时间戳</li><li>接下来的3个字节是机器标识码</li><li>紧接的两个字节由进程id组成（PID）</li><li>最后三个字节是随机数。</li></ul><p>MongoDB中存储的文档必须有一个"_id"键。这个键的值可以是任何类型的，默认是个ObjectId对象。</p><p>在一个集合里面，每个文档都有唯一的"_id"值，来确保集合里面每个文档都能被唯一标识。</p></li></ul></li><li><p>10w条数据怎么限定查询出来的结果只有100条</p><ul><li>limit —&gt; 限制聚合管道返回的文档数。</li></ul></li><li><p>索引有什么用处</p><ul><li><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p><p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p></li></ul></li><li><p>索引的实现原理</p><ul><li>B-树<ul><li>多路，非二叉树</li><li>每个节点 既保存数据 又保存索引</li><li>搜索时 相当于二分查找</li></ul></li></ul></li><li><p>副本集是什么东西，有什么好处</p><ul><li>N 个节点的集群</li><li>任何节点可作为主节点</li><li>所有写入操作都在主节点上</li><li>自动故障转移</li><li>自动恢复</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="redis">redis<a class="hash-link" href="#redis" title="标题的直接链接">​</a></h3><p><a href="https://zhuanlan.zhihu.com/p/62957534" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/62957534</a></p><p><a href="https://zhuanlan.zhihu.com/p/460236324" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/460236324</a></p><p><a href="https://zhuanlan.zhihu.com/p/130923806" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/130923806</a></p><ul><li><p>reids简单介绍、特点、优点、缺点</p></li><li><p>redis分布式锁</p></li><li><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p></li><li><p>数据类型有哪些</p><ul><li>string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)</li></ul></li><li><p>zset是用什么实现的</p><ul><li>跳表 skiplist</li></ul></li><li><p>优点</p><ul><li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
支持数据持久化，支持AOF和RDB两种持久化方式。
支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul></li><li><p>redis集群模式</p><ul><li>主从复制</li><li>哨兵集群<ul><li>哨兵是 Redis 的一种运行模式，它专注于<strong>对 Redis 实例（主节点、从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个 Redis 系统的可用性</strong>。、</li><li>Redis 哨兵具备的能力有如下几个：<ul><li><strong>监控</strong>：持续监控 master 、slave 是否处于预期工作状态。</li><li><strong>自动切换主库</strong>：当 Master 运行故障，哨兵启动自动故障恢复流程：从 slave 中选择一台作为新 master。</li><li><strong>通知</strong>：让 slave 执行 replicaof ，与新的 master 同步；并且通知客户端与新 master 建立连接。</li></ul></li></ul></li></ul></li><li><p><strong>Cluster 集群</strong></p><ul><li><p>有 Cluster 集群实现高可用，哨兵集群监控的 Redis 集群是主从架构，无法横向拓展。<strong>使用 Redis Cluster 集群，主要解决了大数据量存储导致的各种慢问题，同时也便于横向拓展。</strong></p><p><strong>在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择。</strong></p></li><li><p>Redis 集群是一种分布式数据库方案，集群通过分片（sharding）来进行数据管理（「分治思想」的一种实践），并提供复制和故障转移功能。</p><p>将数据划分为 16384 的 slots，每个节点负责一部分槽位。槽位的信息存储于每个节点中。</p><p>它是去中心化的，如图所示，该集群由三个 Redis 节点组成，每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。</p></li></ul></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="算法">算法<a class="hash-link" href="#算法" title="标题的直接链接">​</a></h2><p>堆排序</p><p>时间轮</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一致性hash">一致性hash<a class="hash-link" href="#一致性hash" title="标题的直接链接">​</a></h4><p><a href="https://www.jianshu.com/p/528ce5cd7e8f" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/528ce5cd7e8f</a></p><p><a href="https://www.zsythink.net/archives/1182" target="_blank" rel="noopener noreferrer">https://www.zsythink.net/archives/1182</a></p><p><a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/lpfuture/p/5796398.html</a></p><ul><li>一致性hash解决什么问题</li><li>数据倾斜问题<ul><li>数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题</li><li>为了解决数据倾斜问题，一致性Hash算法引入了<code>虚拟节点机制</code>，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。</li></ul></li></ul><p>尾递归</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据结构">数据结构<a class="hash-link" href="#数据结构" title="标题的直接链接">​</a></h2><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="跳表">跳表<a class="hash-link" href="#跳表" title="标题的直接链接">​</a></h4><blockquote><p>跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1539038" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1539038</a></p><ul><li><p>跳表的思想</p><p>用“空间换时间”，通过给链表建立索引，提高查找效率</p></li><li><p><strong>查询操作</strong></p></li><li><p><strong>删除操作</strong></p></li><li><p><strong>插入操作</strong></p></li><li><p>对于跳表以及跳表的同类竞争产品：红黑树，为啥Redis的有序集合(zset) 使用跳表呢？</p><ul><li>因为跳表除了查找插入维护和红黑树有着差不多的效率，它是个链表，能确定范围区间，而区间问题在树上可能就没那么方便查询啦。</li></ul></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="红黑树">红黑树<a class="hash-link" href="#红黑树" title="标题的直接链接">​</a></h4>]]></content:encoded>
        </item>
    </channel>
</rss>